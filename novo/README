# IA Energia — Gemini + Context Cache

## Pré-requisitos

- Node 20+
- Docker (para Postgres/Redis) ou instâncias próprias

## Subir infraestrutura

````bash
docker compose up -d

Configurar .env
cp .env.example .env
# edite GEMINI_API_KEY
Migrar banco
npm run db:migrate
Rodar servidor
npm run dev
# abre em http://localhost:3000
Endpoints

POST /admin/policies/:id

{
  "title": "Regras Planta 1",
  "body": "# Conhecimento base...",
  "rulesSystem": "Você é especialista...",
  "model": "gemini-2.0-flash-001"
}

GET /admin/policies/:id/caches

POST /ask
{
"policyId": "empresaA/planta1",
"policyBody": "# Conhecimento base...",
"rulesSystem": "Você é especialista...",
"siteName": "Planta 1",
"readings": [{"ts":"2025-09-01T00:00:00Z","kwh":120}, ...]
}

Padrões

systemInstruction = regras (não vai pro cache)

cachedContent = conhecimento (imutável; só estende TTL)

contents = mensagem do usuário



`I = V_shunt / R_shunt` *(Amperes)*
Saturação para ruído: `I = max(I, 0)`


**5.3 Potência**
DC ou referência comum: `P = VCC * I` *(Watts)*
Se medição de **V_carga** separada: `P = V_carga * I`


**5.3.1 Fator de Potência (opcional, AC)**
Se tiver medição de deslocamento de fase: `P_ativa = V_rms * I_rms * FP` → `FP = P_ativa / (V_rms * I_rms)`
Guardamos **FP acumulado** como média ponderada por tempo.


**5.4 Energia (integração)**
`dt = (millis() - lastMillis)/1000.0` *(s)*
`E_J += P * dt` *(J)*
Conversões: `Wh = E_J / 3600`, `kWh = E_J / 3_600_000`


> Calibrações: offset do ADC, ganho do shunt, filtro passa‑baixa (média móvel exponencial), *debounce* para pulsos.


---


## 2) Implementação TypeScript — Telemetria


**`src/energy/telemetry.ts`**
```ts
export type TelemetryConfig = {
  VCC: number;           // Volts
  R_shunt: number;       // Ohms
  adcBits?: 10 | 12;     // default 10
  adcMax?: number;       // override (ex.: 4095 p/ 12 bits)
  emaAlpha?: number;     // 0..1 filtro EMA
};


export type TelemetryState = {
  lastMillis: number;
  E_J: number;          // energia acumulada (J)
  emaI?: number;        // corrente filtrada
  emaP?: number;        // potência filtrada
  fpAccum?: { sum: number; w: number }; // acumulador de FP (opcional)
};


export type SampleIn = {
  millis: number;            // timestamp do microcontrolador (ms)
  analogValue: number;       // 0..(2^n - 1)
  V_carga?: number;          // opcional (Volts)
  fp?: number;               // opcional (0..1)
};


export type SampleOut = {
  I: number; P: number; V_shunt: number; V_base: number; dt: number; E_J: number; FP?: number;
};


export function stepTelemetry(cfg: TelemetryConfig, st: TelemetryState, s: SampleIn): SampleOut {
  const bits = cfg.adcBits ?? 10;
  const max = cfg.adcMax ?? (2 ** bits - 1);
  const V_base = s.V_carga ?? cfg.VCC;
  const V_shunt = (s.analogValue * (cfg.VCC / max));
  let I = Math.max(0, V_shunt / cfg.R_shunt);
  const P_inst = V_base * I;


  // filtros EMA
  const a = cfg.emaAlpha ?? 0.2;
  st.emaI = st.emaI == null ? I : (a * I + (1 - a) * st.emaI);
  st.emaP = st.emaP == null ? P_inst : (a * P_inst + (1 - a) * st.emaP);


  const dt = Math.max(0, (s.millis - (st.lastMillis || s.millis)) / 1000);
  st.lastMillis = s.millis;


  const P = st.emaP ?? P_inst;
  st.E_J = (st.E_J || 0) + P * dt;


  // fator de potência acumulado (se fornecido)
  let FP: number | undefined = undefined;
  if (typeof s.fp === 'number') {
    st.fpAccum = st.fpAccum || { sum: 0, w: 0 };
    st.fpAccum.sum += s.fp * dt;
    st.fpAccum.w += dt;
    FP = st.fpAccum.sum / Math.max(st.fpAccum.w, 1e-9);
  }


  return { I: st.emaI!, P, V_shunt, V_base, dt, E_J: st.E_J, FP };
}
3) Engine de Regras (notificar/desligar) com histerese e debounce

DSL de regra (JSON):


{
"id": "pico_horario",
"when": "between",
"window": { "tz": "America/Fortaleza", "start": "18:00", "end": "21:00" },
"metric": "P", // P (W), I (A), FP, kWh (derivado de E_J)
"op": ">",
"threshold": 20000, // 20 kW
"hysteresis": 1000, // 1 kW para voltar
"forSeconds": 120, // mantém por 2 min
"actions": [
{ "type": "notify", "message": "Pico acima de 20 kW no horário crítico" },
{ "type": "trip", "relay": "MAIN_A" }
]
}
````
